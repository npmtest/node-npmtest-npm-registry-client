{"/home/travis/build/npmtest/node-npmtest-npm-registry-client/test.js":"/* istanbul instrument in package npmtest_npm_registry_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/lib.npmtest_npm_registry_client.js":"/* istanbul instrument in package npmtest_npm_registry_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_npm_registry_client = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_npm_registry_client = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-npm-registry-client && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_npm_registry_client */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_npm_registry_client\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_npm_registry_client.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_npm_registry_client.rollup.js'] =\n            local.assetsDict['/assets.npmtest_npm_registry_client.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_npm_registry_client.__dirname + '/lib.npmtest_npm_registry_client.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/index.js":"// utilities for working with the js-registry site.\n\nmodule.exports = RegClient\n\nvar npmlog\ntry {\n  npmlog = require('npmlog')\n} catch (er) {\n  npmlog = {\n    error: noop,\n    warn: noop,\n    info: noop,\n    verbose: noop,\n    silly: noop,\n    http: noop,\n    pause: noop,\n    resume: noop\n  }\n}\n\nfunction noop () {}\n\nfunction RegClient (config) {\n  this.config = Object.create(config || {})\n\n  this.config.proxy = this.config.proxy || {}\n  if (!this.config.proxy.https && this.config.proxy.http) {\n    this.config.proxy.https = this.config.proxy.http\n  }\n\n  this.config.ssl = this.config.ssl || {}\n  if (this.config.ssl.strict === undefined) this.config.ssl.strict = true\n\n  this.config.retry = this.config.retry || {}\n  if (typeof this.config.retry.retries !== 'number') this.config.retry.retries = 2\n  if (typeof this.config.retry.factor !== 'number') this.config.retry.factor = 10\n  if (typeof this.config.retry.minTimeout !== 'number') this.config.retry.minTimeout = 10000\n  if (typeof this.config.retry.maxTimeout !== 'number') this.config.retry.maxTimeout = 60000\n  if (typeof this.config.maxSockets !== 'number') this.config.maxSockets = 50\n\n  this.config.userAgent = this.config.userAgent || 'node/' + process.version\n  this.config.defaultTag = this.config.defaultTag || 'latest'\n\n  this.log = this.config.log || npmlog\n  delete this.config.log\n\n  var client = this\n  client.access = require('./lib/access')\n  client.adduser = require('./lib/adduser')\n  client.attempt = require('./lib/attempt')\n  client.authify = require('./lib/authify')\n  client.deprecate = require('./lib/deprecate')\n  client.distTags = Object.create(client)\n  client.distTags.add = require('./lib/dist-tags/add')\n  client.distTags.fetch = require('./lib/dist-tags/fetch')\n  client.distTags.rm = require('./lib/dist-tags/rm')\n  client.distTags.set = require('./lib/dist-tags/set')\n  client.distTags.update = require('./lib/dist-tags/update')\n  client.fetch = require('./lib/fetch')\n  client.get = require('./lib/get')\n  client.initialize = require('./lib/initialize')\n  client.logout = require('./lib/logout')\n  client.ping = require('./lib/ping')\n  client.publish = require('./lib/publish')\n  client.request = require('./lib/request')\n  client.sendAnonymousCLIMetrics = require('./lib/send-anonymous-CLI-metrics')\n  client.star = require('./lib/star')\n  client.stars = require('./lib/stars')\n  client.tag = require('./lib/tag')\n  client.team = require('./lib/team')\n  client.unpublish = require('./lib/unpublish')\n  client.whoami = require('./lib/whoami')\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/access.js":"module.exports = access\n\nvar assert = require('assert')\nvar url = require('url')\nvar npa = require('npm-package-arg')\nvar subcommands = {}\n\nfunction access (sub, uri, params, cb) {\n  accessAssertions(sub, uri, params, cb)\n  return subcommands[sub].call(this, uri, params, cb)\n}\n\nsubcommands.public = function (uri, params, cb) {\n  return setAccess.call(this, 'public', uri, params, cb)\n}\nsubcommands.restricted = function (uri, params, cb) {\n  return setAccess.call(this, 'restricted', uri, params, cb)\n}\n\nfunction setAccess (access, uri, params, cb) {\n  return this.request(apiUri(uri, 'package', params.package, 'access'), {\n    method: 'POST',\n    auth: params.auth,\n    body: JSON.stringify({ access: access })\n  }, cb)\n}\n\nsubcommands.grant = function (uri, params, cb) {\n  var reqUri = apiUri(uri, 'team', params.scope, params.team, 'package')\n  return this.request(reqUri, {\n    method: 'PUT',\n    auth: params.auth,\n    body: JSON.stringify({\n      permissions: params.permissions,\n      package: params.package\n    })\n  }, cb)\n}\n\nsubcommands.revoke = function (uri, params, cb) {\n  var reqUri = apiUri(uri, 'team', params.scope, params.team, 'package')\n  return this.request(reqUri, {\n    method: 'DELETE',\n    auth: params.auth,\n    body: JSON.stringify({\n      package: params.package\n    })\n  }, cb)\n}\n\nsubcommands['ls-packages'] = function (uri, params, cb, type) {\n  type = type || (params.team ? 'team' : 'org')\n  var client = this\n  var uriParams = '?format=cli'\n  var reqUri = apiUri(uri, type, params.scope, params.team, 'package')\n  return client.request(reqUri + uriParams, {\n    method: 'GET',\n    auth: params.auth\n  }, function (err, perms) {\n    if (err && err.statusCode === 404 && type === 'org') {\n      subcommands['ls-packages'].call(client, uri, params, cb, 'user')\n    } else {\n      cb(err, perms && translatePermissions(perms))\n    }\n  })\n}\n\nsubcommands['ls-collaborators'] = function (uri, params, cb) {\n  var uriParams = '?format=cli'\n  if (params.user) {\n    uriParams += ('&user=' + encodeURIComponent(params.user))\n  }\n  var reqUri = apiUri(uri, 'package', params.package, 'collaborators')\n  return this.request(reqUri + uriParams, {\n    method: 'GET',\n    auth: params.auth\n  }, function (err, perms) {\n    cb(err, perms && translatePermissions(perms))\n  })\n}\n\nsubcommands.edit = function () {\n  throw new Error('edit subcommand is not implemented yet')\n}\n\nfunction apiUri (registryUri) {\n  var path = Array.prototype.slice.call(arguments, 1)\n    .filter(function (x) { return x })\n    .map(encodeURIComponent)\n    .join('/')\n  return url.resolve(registryUri, '-/' + path)\n}\n\nfunction accessAssertions (subcommand, uri, params, cb) {\n  assert(subcommands.hasOwnProperty(subcommand),\n         'access subcommand must be one of ' +\n         Object.keys(subcommands).join(', '))\n  typeChecks({\n    'uri': [uri, 'string'],\n    'params': [params, 'object'],\n    'auth': [params.auth, 'object'],\n    'callback': [cb, 'function']\n  })\n  if (contains([\n    'public', 'restricted'\n  ], subcommand)) {\n    typeChecks({ 'package': [params.package, 'string'] })\n    assert(!!npa(params.package).scope,\n           'access commands are only accessible for scoped packages')\n  }\n  if (contains(['grant', 'revoke', 'ls-packages'], subcommand)) {\n    typeChecks({ 'scope': [params.scope, 'string'] })\n  }\n  if (contains(['grant', 'revoke'], subcommand)) {\n    typeChecks({ 'team': [params.team, 'string'] })\n  }\n  if (subcommand === 'grant') {\n    typeChecks({ 'permissions': [params.permissions, 'string'] })\n    assert(params.permissions === 'read-only' ||\n           params.permissions === 'read-write',\n           'permissions must be either read-only or read-write')\n  }\n}\n\nfunction typeChecks (specs) {\n  Object.keys(specs).forEach(function (key) {\n    var checks = specs[key]\n    /* eslint valid-typeof:0 */\n    assert(typeof checks[0] === checks[1],\n           key + ' is required and must be of type ' + checks[1])\n  })\n}\n\nfunction contains (arr, item) {\n  return arr.indexOf(item) !== -1\n}\n\nfunction translatePermissions (perms) {\n  var newPerms = {}\n  for (var key in perms) {\n    if (perms.hasOwnProperty(key)) {\n      if (perms[key] === 'read') {\n        newPerms[key] = 'read-only'\n      } else if (perms[key] === 'write') {\n        newPerms[key] = 'read-write'\n      } else {\n        // This shouldn't happen, but let's not break things\n        // if the API starts returning different things.\n        newPerms[key] = perms[key]\n      }\n    }\n  }\n  return newPerms\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/adduser.js":"module.exports = adduser\n\nvar url = require('url')\nvar assert = require('assert')\nvar extend = Object.assign || require('util')._extend\n\nfunction adduser (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to adduser')\n  assert(\n    params && typeof params === 'object',\n    'must pass params to adduser'\n  )\n  assert(typeof cb === 'function', 'must pass callback to adduser')\n\n  assert(params.auth && typeof params.auth, 'must pass auth to adduser')\n  var auth = params.auth\n  assert(typeof auth.username === 'string', 'must include username in auth')\n  assert(typeof auth.password === 'string', 'must include password in auth')\n  assert(typeof auth.email === 'string', 'must include email in auth')\n\n  // normalize registry URL\n  if (uri.slice(-1) !== '/') uri += '/'\n\n  var username = auth.username.trim()\n  var password = auth.password.trim()\n  var email = auth.email.trim()\n\n  // validation\n  if (!username) return cb(new Error('No username supplied.'))\n  if (!password) return cb(new Error('No password supplied.'))\n  if (!email) return cb(new Error('No email address supplied.'))\n  if (!email.match(/^[^@]+@[^.]+\\.[^.]+/)) {\n    return cb(new Error('Please use a real email address.'))\n  }\n\n  var userobj = {\n    _id: 'org.couchdb.user:' + username,\n    name: username,\n    password: password,\n    email: email,\n    type: 'user',\n    roles: [],\n    date: new Date().toISOString()\n  }\n\n  var token = this.config.couchToken\n  if (this.couchLogin) this.couchLogin.token = null\n\n  cb = done.call(this, token, cb)\n\n  var logObj = Object.keys(userobj).map(function (k) {\n    if (k === 'password') return [k, 'XXXXX']\n    return [k, userobj[k]]\n  }).reduce(function (s, kv) {\n    s[kv[0]] = kv[1]\n    return s\n  }, {})\n\n  this.log.verbose('adduser', 'before first PUT', logObj)\n\n  var client = this\n\n  uri = url.resolve(uri, '-/user/org.couchdb.user:' + encodeURIComponent(username))\n  var options = {\n    method: 'PUT',\n    body: userobj,\n    auth: auth\n  }\n  this.request(\n    uri,\n    extend({}, options),\n    function (error, data, json, response) {\n      if (!error || !response || response.statusCode !== 409) {\n        return cb(error, data, json, response)\n      }\n\n      client.log.verbose('adduser', 'update existing user')\n      return client.request(\n        uri + '?write=true',\n        { auth: auth },\n        function (er, data, json, response) {\n          if (er || data.error) {\n            return cb(er, data, json, response)\n          }\n          Object.keys(data).forEach(function (k) {\n            if (!userobj[k] || k === 'roles') {\n              userobj[k] = data[k]\n            }\n          })\n          client.log.verbose('adduser', 'userobj', logObj)\n          client.request(uri + '/-rev/' + userobj._rev, options, cb)\n        }\n      )\n    }\n  )\n\n  function done (token, cb) {\n    return function (error, data, json, response) {\n      if (!error && (!response || response.statusCode === 201)) {\n        return cb(error, data, json, response)\n      }\n\n      // there was some kind of error, reinstate previous auth/token/etc.\n      if (client.couchLogin) {\n        client.couchLogin.token = token\n        if (client.couchLogin.tokenSet) {\n          client.couchLogin.tokenSet(token)\n        }\n      }\n\n      client.log.verbose('adduser', 'back', [error, data, json])\n      if (!error) {\n        error = new Error(\n          ((response && response.statusCode) || '') + ' ' +\n          'Could not create user\\n' + JSON.stringify(data)\n        )\n      }\n\n      if (response && (response.statusCode === 401 || response.statusCode === 403)) {\n        client.log.warn('adduser', 'Incorrect username or password\\n' +\n                                   'You can reset your account by visiting:\\n' +\n                                   '\\n' +\n                                   '    https://npmjs.org/forgot\\n')\n      }\n\n      return cb(error)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/attempt.js":"var retry = require('retry')\n\nmodule.exports = attempt\n\nfunction attempt (cb) {\n  // Tuned to spread 3 attempts over about a minute.\n  // See formula at <https://github.com/tim-kos/node-retry>.\n  var operation = retry.operation(this.config.retry)\n\n  var client = this\n  operation.attempt(function (currentAttempt) {\n    client.log.info(\n      'attempt',\n      'registry request try #' + currentAttempt +\n        ' at ' + (new Date()).toLocaleTimeString()\n    )\n\n    cb(operation)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/authify.js":"module.exports = authify\n\nfunction authify (authed, parsed, headers, credentials) {\n  if (credentials && credentials.token) {\n    this.log.verbose('request', 'using bearer token for auth')\n    headers.authorization = 'Bearer ' + credentials.token\n\n    return null\n  }\n\n  if (authed) {\n    if (credentials && credentials.username && credentials.password) {\n      var username = encodeURIComponent(credentials.username)\n      var password = encodeURIComponent(credentials.password)\n      parsed.auth = username + ':' + password\n    } else {\n      return new Error(\n        'This request requires auth credentials. Run `npm login` and repeat the request.'\n      )\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/deprecate.js":"module.exports = deprecate\n\nvar assert = require('assert')\nvar semver = require('semver')\n\nfunction deprecate (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to deprecate')\n  assert(params && typeof params === 'object', 'must pass params to deprecate')\n  assert(typeof cb === 'function', 'must pass callback to deprecate')\n\n  assert(typeof params.version === 'string', 'must pass version to deprecate')\n  assert(typeof params.message === 'string', 'must pass message to deprecate')\n  assert(\n    params.auth && typeof params.auth === 'object',\n    'must pass auth to deprecate'\n  )\n\n  var version = params.version\n  var message = params.message\n  var auth = params.auth\n\n  if (semver.validRange(version) === null) {\n    return cb(new Error('invalid version range: ' + version))\n  }\n\n  this.get(uri + '?write=true', { auth: auth }, function (er, data) {\n    if (er) return cb(er)\n    // filter all the versions that match\n    Object.keys(data.versions).filter(function (v) {\n      return semver.satisfies(v, version)\n    }).forEach(function (v) {\n      data.versions[v].deprecated = message\n    })\n    // now update the doc on the registry\n    var options = {\n      method: 'PUT',\n      body: data,\n      auth: auth\n    }\n    this.request(uri, options, cb)\n  }.bind(this))\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/fetch.js":"var assert = require('assert')\nvar url = require('url')\n\nvar request = require('request')\nvar once = require('once')\n\nmodule.exports = fetch\n\nfunction fetch (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass uri to request')\n  assert(params && typeof params === 'object', 'must pass params to request')\n  assert(typeof cb === 'function', 'must pass callback to request')\n\n  cb = once(cb)\n\n  var client = this\n  this.attempt(function (operation) {\n    makeRequest.call(client, uri, params, function (er, req) {\n      if (er) return cb(er)\n\n      req.once('error', retryOnError)\n\n      function retryOnError (er) {\n        if (operation.retry(er)) {\n          client.log.info('retry', 'will retry, error on last attempt: ' + er)\n        } else {\n          cb(er)\n        }\n      }\n\n      req.on('response', function (res) {\n        client.log.http('fetch', '' + res.statusCode, uri)\n        req.removeListener('error', retryOnError)\n\n        var er\n        var statusCode = res && res.statusCode\n        if (statusCode === 200) {\n          // Work around bug in node v0.10.0 where the CryptoStream\n          // gets stuck and never starts reading again.\n          res.resume()\n          if (process.version === 'v0.10.0') unstick(res)\n\n          req.once('error', function (er) {\n            res.emit('error', er)\n          })\n\n          return cb(null, res)\n          // Only retry on 408, 5xx or no `response`.\n        } else if (statusCode === 408) {\n          er = new Error('request timed out')\n        } else if (statusCode >= 500) {\n          er = new Error('server error ' + statusCode)\n        }\n\n        if (er && operation.retry(er)) {\n          client.log.info('retry', 'will retry, error on last attempt: ' + er)\n        } else {\n          cb(new Error('fetch failed with status code ' + statusCode))\n        }\n      })\n    })\n  })\n}\n\nfunction unstick (response) {\n  response.resume = (function (orig) {\n    return function () {\n      var ret = orig.apply(response, arguments)\n      if (response.socket.encrypted) response.socket.encrypted.read(0)\n      return ret\n    }\n  })(response.resume)\n}\n\nfunction makeRequest (remote, params, cb) {\n  var parsed = url.parse(remote)\n  this.log.http('fetch', 'GET', parsed.href)\n\n  var headers = params.headers || {}\n  var er = this.authify(\n    params.auth && params.auth.alwaysAuth,\n    parsed,\n    headers,\n    params.auth\n  )\n  if (er) return cb(er)\n\n  var opts = this.initialize(\n    parsed,\n    'GET',\n    'application/x-tar, application/vnd.github+json; q=0.1',\n    headers\n  )\n  // always want to follow redirects for fetch\n  opts.followRedirect = true\n\n  cb(null, request(opts))\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/get.js":"module.exports = get\n\nvar assert = require('assert')\nvar url = require('url')\n\n/*\n * This is meant to be overridden in specific implementations if you\n * want specialized behavior for metadata (i.e. caching).\n */\nfunction get (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to get')\n  assert(params && typeof params === 'object', 'must pass params to get')\n  assert(typeof cb === 'function', 'must pass callback to get')\n\n  var parsed = url.parse(uri)\n  assert(\n    parsed.protocol === 'http:' || parsed.protocol === 'https:',\n    'must have a URL that starts with http: or https:'\n  )\n\n  this.request(uri, params, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/initialize.js":"var crypto = require('crypto')\nvar HttpAgent = require('http').Agent\nvar HttpsAgent = require('https').Agent\n\nvar pkg = require('../package.json')\n\nmodule.exports = initialize\n\nfunction initialize (uri, method, accept, headers) {\n  if (!this.config.sessionToken) {\n    this.config.sessionToken = crypto.randomBytes(8).toString('hex')\n    this.log.verbose('request id', this.config.sessionToken)\n  }\n  if (this.config.isFromCI == null) {\n    this.config.isFromCI = Boolean(\n      process.env['CI'] === 'true' || process.env['TDDIUM'] ||\n      process.env['JENKINS_URL'] || process.env['bamboo.buildKey'])\n  }\n\n  var opts = {\n    url: uri,\n    method: method,\n    headers: headers,\n    localAddress: this.config.proxy.localAddress,\n    strictSSL: this.config.ssl.strict,\n    cert: this.config.ssl.certificate,\n    key: this.config.ssl.key,\n    ca: this.config.ssl.ca,\n    agent: getAgent.call(this, uri.protocol)\n  }\n\n  // allow explicit disabling of proxy in environment via CLI\n  //\n  // how false gets here is the CLI's problem (it's gross)\n  if (this.config.proxy.http === false) {\n    opts.proxy = null\n  } else {\n    // request will not pay attention to the NOPROXY environment variable if a\n    // config value named proxy is passed in, even if it's set to null.\n    var proxy\n    if (uri.protocol === 'https:') {\n      proxy = this.config.proxy.https\n    } else {\n      proxy = this.config.proxy.http\n    }\n    if (typeof proxy === 'string') opts.proxy = proxy\n  }\n\n  headers.version = this.version || pkg.version\n  headers.accept = accept\n\n  if (this.refer) headers.referer = this.refer\n\n  headers['npm-session'] = this.config.sessionToken\n  headers['npm-in-ci'] = String(this.config.isFromCI)\n  headers['user-agent'] = this.config.userAgent\n  if (this.config.scope) {\n    headers['npm-scope'] = this.config.scope\n  }\n\n  return opts\n}\n\nfunction getAgent (protocol) {\n  if (protocol === 'https:') {\n    if (!this.httpsAgent) {\n      this.httpsAgent = new HttpsAgent({\n        keepAlive: true,\n        maxSockets: this.config.maxSockets,\n        localAddress: this.config.proxy.localAddress,\n        rejectUnauthorized: this.config.ssl.strict,\n        ca: this.config.ssl.ca,\n        cert: this.config.ssl.certificate,\n        key: this.config.ssl.key\n      })\n    }\n\n    return this.httpsAgent\n  } else {\n    if (!this.httpAgent) {\n      this.httpAgent = new HttpAgent({\n        keepAlive: true,\n        maxSockets: this.config.maxSockets,\n        localAddress: this.config.proxy.localAddress\n      })\n    }\n\n    return this.httpAgent\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/logout.js":"module.exports = logout\n\nvar assert = require('assert')\nvar url = require('url')\n\nfunction logout (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to logout')\n  assert(params && typeof params === 'object', 'must pass params to logout')\n  assert(typeof cb === 'function', 'must pass callback to star')\n\n  var auth = params.auth\n  assert(auth && typeof auth === 'object', 'must pass auth to logout')\n  assert(typeof auth.token === 'string', 'can only log out for token auth')\n\n  uri = url.resolve(uri, '-/user/token/' + auth.token)\n  var options = {\n    method: 'DELETE',\n    auth: auth\n  }\n\n  this.log.verbose('logout', 'invalidating session token for user')\n  this.request(uri, options, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/ping.js":"module.exports = ping\n\nvar url = require('url')\nvar assert = require('assert')\n\nfunction ping (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to ping')\n  assert(params && typeof params === 'object', 'must pass params to ping')\n  assert(typeof cb === 'function', 'must pass callback to ping')\n\n  var auth = params.auth\n  assert(auth && typeof auth === 'object', 'must pass auth to ping')\n\n  this.request(url.resolve(uri, '-/ping?write=true'), { auth: auth }, function (er, fullData, data, response) {\n    if (er || fullData) {\n      cb(er, fullData, data, response)\n    } else {\n      cb(new Error('No data received'))\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/publish.js":"module.exports = publish\n\nvar url = require('url')\nvar semver = require('semver')\nvar crypto = require('crypto')\nvar Stream = require('stream').Stream\nvar assert = require('assert')\nvar fixer = require('normalize-package-data').fixer\nvar concat = require('concat-stream')\n\nfunction escaped (name) {\n  return name.replace('/', '%2f')\n}\n\nfunction publish (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to publish')\n  assert(params && typeof params === 'object', 'must pass params to publish')\n  assert(typeof cb === 'function', 'must pass callback to publish')\n\n  var access = params.access\n  assert(\n    (!access) || ['public', 'restricted'].indexOf(access) !== -1,\n    \"if present, access level must be either 'public' or 'restricted'\"\n  )\n\n  var auth = params.auth\n  assert(auth && typeof auth === 'object', 'must pass auth to publish')\n  if (!(auth.token ||\n        (auth.password && auth.username && auth.email))) {\n    var er = new Error('auth required for publishing')\n    er.code = 'ENEEDAUTH'\n    return cb(er)\n  }\n\n  var metadata = params.metadata\n  assert(\n    metadata && typeof metadata === 'object',\n    'must pass package metadata to publish'\n  )\n  try {\n    fixer.fixNameField(metadata, {strict: true, allowLegacyCase: true})\n  } catch (er) {\n    return cb(er)\n  }\n  var version = semver.clean(metadata.version)\n  if (!version) return cb(new Error('invalid semver: ' + metadata.version))\n  metadata.version = version\n\n  var body = params.body\n  assert(body, 'must pass package body to publish')\n  assert(body instanceof Stream, 'package body passed to publish must be a stream')\n  var client = this\n  var sink = concat(function (tarbuffer) {\n    putFirst.call(client, uri, metadata, tarbuffer, access, auth, cb)\n  })\n  sink.on('error', cb)\n  body.pipe(sink)\n}\n\nfunction putFirst (registry, data, tarbuffer, access, auth, cb) {\n  // optimistically try to PUT all in one single atomic thing.\n  // If 409, then GET and merge, try again.\n  // If other error, then fail.\n\n  var root = {\n    _id: data.name,\n    name: data.name,\n    description: data.description,\n    'dist-tags': {},\n    versions: {},\n    readme: data.readme || ''\n  }\n\n  if (access) root.access = access\n\n  if (!auth.token) {\n    root.maintainers = [{ name: auth.username, email: auth.email }]\n    data.maintainers = JSON.parse(JSON.stringify(root.maintainers))\n  }\n\n  root.versions[ data.version ] = data\n  var tag = data.tag || this.config.defaultTag\n  root['dist-tags'][tag] = data.version\n\n  var tbName = data.name + '-' + data.version + '.tgz'\n  var tbURI = data.name + '/-/' + tbName\n\n  data._id = data.name + '@' + data.version\n  data.dist = data.dist || {}\n  data.dist.shasum = crypto.createHash('sha1').update(tarbuffer).digest('hex')\n  data.dist.tarball = url.resolve(registry, tbURI)\n                         .replace(/^https:\\/\\//, 'http://')\n\n  root._attachments = {}\n  root._attachments[ tbName ] = {\n    'content_type': 'application/octet-stream',\n    'data': tarbuffer.toString('base64'),\n    'length': tarbuffer.length\n  }\n\n  var fixed = url.resolve(registry, escaped(data.name))\n  var client = this\n  var options = {\n    method: 'PUT',\n    body: root,\n    auth: auth\n  }\n  this.request(fixed, options, function (er, parsed, json, res) {\n    var r409 = 'must supply latest _rev to update existing package'\n    var r409b = 'Document update conflict.'\n    var conflict = res && res.statusCode === 409\n    if (parsed && (parsed.reason === r409 || parsed.reason === r409b)) {\n      conflict = true\n    }\n\n    // a 409 is typical here.  GET the data and merge in.\n    if (er && !conflict) {\n      client.log.error('publish', 'Failed PUT ' + (res && res.statusCode))\n      return cb(er)\n    }\n\n    if (!er && !conflict) return cb(er, parsed, json, res)\n\n    // let's see what versions are already published.\n    client.request(fixed + '?write=true', { auth: auth }, function (er, current) {\n      if (er) return cb(er)\n\n      putNext.call(client, registry, data.version, root, current, auth, cb)\n    })\n  })\n}\n\nfunction putNext (registry, newVersion, root, current, auth, cb) {\n  // already have the tardata on the root object\n  // just merge in existing stuff\n  var curVers = Object.keys(current.versions || {}).map(function (v) {\n    return semver.clean(v, true)\n  }).concat(Object.keys(current.time || {}).map(function (v) {\n    if (semver.valid(v, true)) return semver.clean(v, true)\n  }).filter(function (v) {\n    return v\n  }))\n\n  if (curVers.indexOf(newVersion) !== -1) {\n    return cb(conflictError(root.name, newVersion))\n  }\n\n  current.versions[newVersion] = root.versions[newVersion]\n  current._attachments = current._attachments || {}\n  for (var i in root) {\n    switch (i) {\n      // objects that copy over the new stuffs\n      case 'dist-tags':\n      case 'versions':\n      case '_attachments':\n        for (var j in root[i]) {\n          current[i][j] = root[i][j]\n        }\n        break\n\n      // ignore these\n      case 'maintainers':\n        break\n\n      // copy\n      default:\n        current[i] = root[i]\n    }\n  }\n  var maint = JSON.parse(JSON.stringify(root.maintainers))\n  root.versions[newVersion].maintainers = maint\n\n  var uri = url.resolve(registry, escaped(root.name))\n  var options = {\n    method: 'PUT',\n    body: current,\n    auth: auth\n  }\n  this.request(uri, options, cb)\n}\n\nfunction conflictError (pkgid, version) {\n  var e = new Error('cannot modify pre-existing version')\n  e.code = 'EPUBLISHCONFLICT'\n  e.pkgid = pkgid\n  e.version = version\n  return e\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/request.js":"module.exports = regRequest\n\n// npm: means\n// 1. https\n// 2. send authorization\n// 3. content-type is 'application/json' -- metadata\n//\nvar assert = require('assert')\nvar url = require('url')\nvar zlib = require('zlib')\nvar Stream = require('stream').Stream\nvar STATUS_CODES = require('http').STATUS_CODES\n\nvar request = require('request')\nvar once = require('once')\n\nfunction regRequest (uri, params, cb_) {\n  assert(typeof uri === 'string', 'must pass uri to request')\n  assert(params && typeof params === 'object', 'must pass params to request')\n  assert(typeof cb_ === 'function', 'must pass callback to request')\n\n  params.method = params.method || 'GET'\n  this.log.verbose('request', 'uri', uri)\n\n  // Since there are multiple places where an error could occur,\n  // don't let the cb be called more than once.\n  var cb = once(cb_)\n\n  if (uri.match(/^\\/?favicon.ico/)) {\n    return cb(new Error(\"favicon.ico isn't a package, it's a picture.\"))\n  }\n\n  var adduserChange = /\\/?-\\/user\\/org\\.couchdb\\.user:([^/]+)\\/-rev/\n  var isUserChange = uri.match(adduserChange)\n  var adduserNew = /\\/?-\\/user\\/org\\.couchdb\\.user:([^/?]+)$/\n  var isNewUser = uri.match(adduserNew)\n  var alwaysAuth = params.auth && params.auth.alwaysAuth\n  var isDelete = params.method === 'DELETE'\n  var isWrite = params.body || isDelete\n\n  if (isUserChange && !isWrite) {\n    return cb(new Error('trying to change user document without writing(?!)'))\n  }\n\n  if (params.authed == null) {\n    // new users can *not* use auth, because they don't *have* auth yet\n    if (isUserChange) {\n      this.log.verbose('request', 'updating existing user; sending authorization')\n      params.authed = true\n    } else if (isNewUser) {\n      this.log.verbose('request', \"new user, so can't send auth\")\n      params.authed = false\n    } else if (alwaysAuth) {\n      this.log.verbose('request', 'always-auth set; sending authorization')\n      params.authed = true\n    } else if (isWrite) {\n      this.log.verbose('request', 'sending authorization for write operation')\n      params.authed = true\n    } else {\n      // most of the time we don't want to auth\n      this.log.verbose('request', 'no auth needed')\n      params.authed = false\n    }\n  }\n\n  var self = this\n  this.attempt(function (operation) {\n    makeRequest.call(self, uri, params, function (er, parsed, raw, response) {\n      if (response) {\n        self.log.verbose('headers', response.headers)\n        if (response.headers['npm-notice']) {\n          self.log.warn('notice', response.headers['npm-notice'])\n        }\n      }\n\n      if (!er || (er.message && er.message.match(/^SSL Error/))) {\n        if (er) er.code = 'ESSL'\n        return cb(er, parsed, raw, response)\n      }\n\n      // Only retry on 408, 5xx or no `response`.\n      var statusCode = response && response.statusCode\n\n      var timeout = statusCode === 408\n      var serverError = statusCode >= 500\n      var statusRetry = !statusCode || timeout || serverError\n      if (er && statusRetry && operation.retry(er)) {\n        self.log.info('retry', 'will retry, error on last attempt: ' + er)\n        return undefined\n      }\n      cb.apply(null, arguments)\n    })\n  })\n}\n\nfunction makeRequest (uri, params, cb_) {\n  var socket\n  var cb = once(function (er, parsed, raw, response) {\n    if (socket) {\n      // The socket might be returned to a pool for re-use, so dont keep\n      // the 'error' listener from here attached.\n      socket.removeListener('error', cb)\n    }\n\n    return cb_(er, parsed, raw, response)\n  })\n\n  var parsed = url.parse(uri)\n  var headers = {}\n\n  // metadata should be compressed\n  headers['accept-encoding'] = 'gzip'\n\n  // metadata should be minified, if the registry supports it\n\n  var er = this.authify(params.authed, parsed, headers, params.auth)\n  if (er) return cb_(er)\n\n  var useCorgi = params.fullMetadata == null ? false : !params.fullMetadata\n\n  var opts = this.initialize(\n    parsed,\n    params.method,\n    useCorgi ? 'application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*' : 'application/json',\n    headers\n  )\n\n  opts.followRedirect = (typeof params.follow === 'boolean' ? params.follow : true)\n  opts.encoding = null // tell request let body be Buffer instance\n\n  if (params.etag) {\n    this.log.verbose('etag', params.etag)\n    headers[params.method === 'GET' ? 'if-none-match' : 'if-match'] = params.etag\n  }\n\n  if (params.lastModified && params.method === 'GET') {\n    this.log.verbose('lastModified', params.lastModified)\n    headers['if-modified-since'] = params.lastModified\n  }\n\n  // figure out wth body is\n  if (params.body) {\n    if (Buffer.isBuffer(params.body)) {\n      opts.body = params.body\n      headers['content-type'] = 'application/json'\n      headers['content-length'] = params.body.length\n    } else if (typeof params.body === 'string') {\n      opts.body = params.body\n      headers['content-type'] = 'application/json'\n      headers['content-length'] = Buffer.byteLength(params.body)\n    } else if (params.body instanceof Stream) {\n      headers['content-type'] = 'application/octet-stream'\n      if (params.body.size) headers['content-length'] = params.body.size\n    } else {\n      delete params.body._etag\n      delete params.body._lastModified\n      opts.json = params.body\n    }\n  }\n\n  this.log.http('request', params.method, parsed.href || '/')\n\n  var done = requestDone.call(this, params.method, uri, cb)\n  var req = request(opts, params.streaming ? undefined : decodeResponseBody(done))\n\n  req.on('error', cb)\n\n  // This should not be necessary, as the HTTP implementation in Node\n  // passes errors occurring on the socket to the request itself. Being overly\n  // cautious comes at a low cost, though.\n  req.on('socket', function (s) {\n    socket = s\n    socket.on('error', cb)\n  })\n\n  if (params.streaming) {\n    req.on('response', function (response) {\n      if (response.statusCode >= 400) {\n        var parts = []\n        response.on('data', function (data) {\n          parts.push(data)\n        })\n        response.on('end', function () {\n          decodeResponseBody(done)(null, response, Buffer.concat(parts))\n        })\n      } else {\n        response.on('end', function () {\n          // don't ever re-use connections that had server errors.\n          // those sockets connect to the Bad Place!\n          if (response.socket && response.statusCode > 500) {\n            response.socket.destroy()\n          }\n        })\n\n        return cb(null, response)\n      }\n    })\n  }\n\n  if (params.body && (params.body instanceof Stream)) {\n    params.body.pipe(req)\n  }\n}\n\nfunction decodeResponseBody (cb) {\n  return function (er, response, data) {\n    if (er) return cb(er, response, data)\n\n    // don't ever re-use connections that had server errors.\n    // those sockets connect to the Bad Place!\n    if (response.socket && response.statusCode > 500) {\n      response.socket.destroy()\n    }\n\n    if (response.headers['content-encoding'] !== 'gzip') {\n      return cb(er, response, data)\n    }\n\n    zlib.gunzip(data, function (er, buf) {\n      if (er) return cb(er, response, data)\n\n      cb(null, response, buf)\n    })\n  }\n}\n\n// cb(er, parsed, raw, response)\nfunction requestDone (method, where, cb) {\n  return function (er, response, data) {\n    if (er) return cb(er)\n\n    var urlObj = url.parse(where)\n    if (urlObj.auth) urlObj.auth = '***'\n    this.log.http(response.statusCode, url.format(urlObj))\n\n    if (Buffer.isBuffer(data)) {\n      data = data.toString()\n    }\n\n    var parsed\n    if (data && typeof data === 'string' && response.statusCode !== 304) {\n      try {\n        parsed = JSON.parse(data)\n      } catch (ex) {\n        ex.message += '\\n' + data\n        this.log.verbose('bad json', data)\n        this.log.error('registry', 'error parsing json')\n        return cb(ex, null, data, response)\n      }\n    } else if (data) {\n      parsed = data\n      data = JSON.stringify(parsed)\n    }\n\n    // expect data with any error codes\n    if (!data && response.statusCode >= 400) {\n      var code = response.statusCode\n      return cb(\n        makeError(code + ' ' + STATUS_CODES[code], null, code),\n        null,\n        data,\n        response\n      )\n    }\n\n    er = null\n    if (parsed && response.headers.etag) {\n      parsed._etag = response.headers.etag\n    }\n\n    if (parsed && response.headers['last-modified']) {\n      parsed._lastModified = response.headers['last-modified']\n    }\n\n    // for the search endpoint, the 'error' property can be an object\n    if ((parsed && parsed.error && typeof parsed.error !== 'object') ||\n        response.statusCode >= 400) {\n      var w = url.parse(where).pathname.substr(1)\n      var name\n      if (!w.match(/^-/)) {\n        w = w.split('/')\n        name = decodeURIComponent(w[w.indexOf('_rewrite') + 1])\n      }\n\n      if (!parsed.error) {\n        er = makeError(\n          'Registry returned ' + response.statusCode +\n          ' for ' + method +\n          ' on ' + where,\n          name,\n          response.statusCode\n        )\n      } else if (name && parsed.error === 'not_found') {\n        er = makeError('404 Not Found: ' + name, name, response.statusCode)\n      } else {\n        er = makeError(\n          parsed.error + ' ' + (parsed.reason || '') + ': ' + (name || w),\n          name,\n          response.statusCode\n        )\n      }\n    }\n    return cb(er, parsed, data, response)\n  }.bind(this)\n}\n\nfunction makeError (message, name, code) {\n  var er = new Error(message)\n  if (name) er.pkgid = name\n  if (code) {\n    er.statusCode = code\n    er.code = 'E' + code\n  }\n  return er\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/send-anonymous-CLI-metrics.js":"module.exports = send\n\nvar assert = require('assert')\nvar url = require('url')\n\nfunction send (registryUrl, params, cb) {\n  assert(typeof registryUrl === 'string', 'must pass registry URI')\n  assert(params && typeof params === 'object', 'must pass params')\n  assert(typeof cb === 'function', 'must pass callback')\n\n  var uri = url.resolve(registryUrl, '-/npm/anon-metrics/v1/' +\n    encodeURIComponent(params.metricId))\n\n  this.request(uri, {\n    method: 'PUT',\n    body: JSON.stringify(params.metrics),\n    authed: false\n  }, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/star.js":"module.exports = star\n\nvar assert = require('assert')\n\nfunction star (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to star')\n  assert(params && typeof params === 'object', 'must pass params to star')\n  assert(typeof cb === 'function', 'must pass callback to star')\n\n  var starred = !!params.starred\n\n  var auth = params.auth\n  assert(auth && typeof auth === 'object', 'must pass auth to star')\n  if (!(auth.token || (auth.password && auth.username && auth.email))) {\n    var er = new Error('Must be logged in to star/unstar packages')\n    er.code = 'ENEEDAUTH'\n    return cb(er)\n  }\n\n  var client = this\n  this.request(uri + '?write=true', { auth: auth }, function (er, fullData) {\n    if (er) return cb(er)\n\n    client.whoami(uri, params, function (er, username) {\n      if (er) return cb(er)\n\n      var data = {\n        _id: fullData._id,\n        _rev: fullData._rev,\n        users: fullData.users || {}\n      }\n\n      if (starred) {\n        client.log.info('starring', data._id)\n        data.users[username] = true\n        client.log.verbose('starring', data)\n      } else {\n        delete data.users[username]\n        client.log.info('unstarring', data._id)\n        client.log.verbose('unstarring', data)\n      }\n\n      var options = {\n        method: 'PUT',\n        body: data,\n        auth: auth\n      }\n      return client.request(uri, options, cb)\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/stars.js":"module.exports = stars\n\nvar assert = require('assert')\nvar url = require('url')\n\nfunction stars (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to stars')\n  assert(params && typeof params === 'object', 'must pass params to stars')\n  assert(typeof cb === 'function', 'must pass callback to stars')\n\n  var auth = params.auth\n  var name = params.username || (auth && auth.username)\n  if (!name) return cb(new Error('must pass either username or auth to stars'))\n  var encoded = encodeURIComponent(name)\n  var path = '-/_view/starredByUser?key=\"' + encoded + '\"'\n\n  this.request(url.resolve(uri, path), { auth: auth }, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/tag.js":"module.exports = tag\n\nvar assert = require('assert')\n\nfunction tag (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to tag')\n  assert(params && typeof params === 'object', 'must pass params to tag')\n  assert(typeof cb === 'function', 'must pass callback to tag')\n\n  assert(typeof params.version === 'string', 'must pass version to tag')\n  assert(typeof params.tag === 'string', 'must pass tag name to tag')\n  assert(\n    params.auth && typeof params.auth === 'object',\n    'must pass auth to tag'\n  )\n\n  var options = {\n    method: 'PUT',\n    body: JSON.stringify(params.version),\n    auth: params.auth\n  }\n  this.request(uri + '/' + params.tag, options, cb)\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/team.js":"module.exports = team\n\nvar assert = require('assert')\nvar url = require('url')\n\nvar subcommands = {}\n\nfunction team (sub, uri, params, cb) {\n  teamAssertions(sub, uri, params, cb)\n  return subcommands[sub].call(this, uri, params, cb)\n}\n\nsubcommands.create = function (uri, params, cb) {\n  return this.request(apiUri(uri, 'org', params.scope, 'team'), {\n    method: 'PUT',\n    auth: params.auth,\n    body: JSON.stringify({\n      name: params.team\n    })\n  }, cb)\n}\n\nsubcommands.destroy = function (uri, params, cb) {\n  return this.request(apiUri(uri, 'team', params.scope, params.team), {\n    method: 'DELETE',\n    auth: params.auth\n  }, cb)\n}\n\nsubcommands.add = function (uri, params, cb) {\n  return this.request(apiUri(uri, 'team', params.scope, params.team, 'user'), {\n    method: 'PUT',\n    auth: params.auth,\n    body: JSON.stringify({\n      user: params.user\n    })\n  }, cb)\n}\n\nsubcommands.rm = function (uri, params, cb) {\n  return this.request(apiUri(uri, 'team', params.scope, params.team, 'user'), {\n    method: 'DELETE',\n    auth: params.auth,\n    body: JSON.stringify({\n      user: params.user\n    })\n  }, cb)\n}\n\nsubcommands.ls = function (uri, params, cb) {\n  var uriParams = '?format=cli'\n  if (params.team) {\n    var reqUri = apiUri(\n      uri, 'team', params.scope, params.team, 'user') + uriParams\n    return this.request(reqUri, {\n      method: 'GET',\n      auth: params.auth\n    }, cb)\n  } else {\n    return this.request(apiUri(uri, 'org', params.scope, 'team') + uriParams, {\n      method: 'GET',\n      auth: params.auth\n    }, cb)\n  }\n}\n\n// TODO - we punted this to v2\n// subcommands.edit = function (uri, params, cb) {\n//   return this.request(apiUri(uri, 'team', params.scope, params.team, 'user'), {\n//     method: 'POST',\n//     auth: params.auth,\n//     body: JSON.stringify({\n//       users: params.users\n//     })\n//   }, cb)\n// }\n\nfunction apiUri (registryUri) {\n  var path = Array.prototype.slice.call(arguments, 1)\n    .map(encodeURIComponent)\n    .join('/')\n  return url.resolve(registryUri, '-/' + path)\n}\n\nfunction teamAssertions (subcommand, uri, params, cb) {\n  assert(subcommand, 'subcommand is required')\n  assert(subcommands.hasOwnProperty(subcommand),\n         'team subcommand must be one of ' + Object.keys(subcommands))\n  assert(typeof uri === 'string', 'registry URI is required')\n  assert(typeof params === 'object', 'params are required')\n  assert(typeof params.auth === 'object', 'auth is required')\n  assert(typeof params.scope === 'string', 'scope is required')\n  assert(!cb || typeof cb === 'function', 'callback must be a function')\n  if (subcommand !== 'ls') {\n    assert(typeof params.team === 'string', 'team name is required')\n  }\n  if (subcommand === 'rm' || subcommand === 'add') {\n    assert(typeof params.user === 'string', 'user is required')\n  }\n  if (subcommand === 'edit') {\n    assert(typeof params.users === 'object' &&\n           params.users.length != null,\n           'users is required')\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/unpublish.js":"module.exports = unpublish\n\n// fetch the data\n// modify to remove the version in question\n// If no versions remaining, then DELETE\n// else, PUT the modified data\n// delete the tarball\n\nvar semver = require('semver')\nvar url = require('url')\nvar chain = require('slide').chain\nvar assert = require('assert')\n\nfunction unpublish (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to unpublish')\n  assert(params && typeof params === 'object', 'must pass params to unpublish')\n  assert(typeof cb === 'function', 'must pass callback to unpublish')\n\n  var ver = params.version\n  var auth = params.auth\n  assert(auth && typeof auth === 'object', 'must pass auth to unpublish')\n\n  var options = {\n    timeout: -1,\n    follow: false,\n    auth: auth\n  }\n  this.get(uri + '?write=true', options, function (er, data) {\n    if (er) {\n      this.log.info('unpublish', uri + ' not published')\n      return cb()\n    }\n    // remove all if no version specified\n    if (!ver) {\n      this.log.info('unpublish', 'No version specified, removing all')\n      return this.request(uri + '/-rev/' + data._rev, { method: 'DELETE', auth: auth }, cb)\n    }\n\n    var versions = data.versions || {}\n    var versionPublic = versions.hasOwnProperty(ver)\n\n    var dist\n    if (!versionPublic) {\n      this.log.info('unpublish', uri + '@' + ver + ' not published')\n    } else {\n      dist = versions[ver].dist\n      this.log.verbose('unpublish', 'removing attachments', dist)\n    }\n\n    delete versions[ver]\n    // if it was the only version, then delete the whole package.\n    if (!Object.keys(versions).length) {\n      this.log.info('unpublish', 'No versions remain, removing entire package')\n      return this.request(uri + '/-rev/' + data._rev, { method: 'DELETE', auth: auth }, cb)\n    }\n\n    if (!versionPublic) return cb()\n\n    var latestVer = data['dist-tags'].latest\n    for (var tag in data['dist-tags']) {\n      if (data['dist-tags'][tag] === ver) delete data['dist-tags'][tag]\n    }\n\n    if (latestVer === ver) {\n      data['dist-tags'].latest =\n        Object.getOwnPropertyNames(versions).sort(semver.compareLoose).pop()\n    }\n\n    var rev = data._rev\n    delete data._revisions\n    delete data._attachments\n    var cb_ = detacher.call(this, uri, data, dist, auth, cb)\n\n    this.request(uri + '/-rev/' + rev, { method: 'PUT', body: data, auth: auth }, function (er) {\n      if (er) {\n        this.log.error('unpublish', 'Failed to update data')\n      }\n      cb_(er)\n    }.bind(this))\n  }.bind(this))\n}\n\nfunction detacher (uri, data, dist, credentials, cb) {\n  return function (er) {\n    if (er) return cb(er)\n    this.get(escape(uri, data.name), { auth: credentials }, function (er, data) {\n      if (er) return cb(er)\n\n      var tb = url.parse(dist.tarball)\n\n      detach.call(this, uri, data, tb.pathname, data._rev, credentials, function (er) {\n        if (er || !dist.bin) return cb(er)\n        chain(Object.keys(dist.bin).map(function (bt) {\n          return function (cb) {\n            var d = dist.bin[bt]\n            detach.call(this, uri, data, url.parse(d.tarball).pathname, null, credentials, cb)\n          }.bind(this)\n        }, this), cb)\n      }.bind(this))\n    }.bind(this))\n  }.bind(this)\n}\n\nfunction detach (uri, data, path, rev, credentials, cb) {\n  if (rev) {\n    path += '/-rev/' + rev\n    this.log.info('detach', path)\n    return this.request(url.resolve(uri, path), { method: 'DELETE', auth: credentials }, cb)\n  }\n  this.get(escape(uri, data.name), { auth: credentials }, function (er, data) {\n    rev = data._rev\n    if (!rev) return cb(new Error('No _rev found in ' + data._id))\n    detach.call(this, data, path, rev, cb)\n  }.bind(this))\n}\n\nfunction escape (base, name) {\n  var escaped = name.replace(/\\//, '%2f')\n  return url.resolve(base, escaped)\n}\n","/home/travis/build/npmtest/node-npmtest-npm-registry-client/node_modules/npm-registry-client/lib/whoami.js":"module.exports = whoami\n\nvar url = require('url')\nvar assert = require('assert')\n\nfunction whoami (uri, params, cb) {\n  assert(typeof uri === 'string', 'must pass registry URI to whoami')\n  assert(params && typeof params === 'object', 'must pass params to whoami')\n  assert(typeof cb === 'function', 'must pass callback to whoami')\n\n  var auth = params.auth\n  assert(auth && typeof auth === 'object', 'must pass auth to whoami')\n\n  if (auth.username) return process.nextTick(cb.bind(this, null, auth.username))\n\n  this.request(url.resolve(uri, '-/whoami'), { auth: auth }, function (er, userdata) {\n    if (er) return cb(er)\n\n    cb(null, userdata.username)\n  })\n}\n"}